---
phase: 03-refiner-pipeline-repair
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - fin_evo_agent/src/evolution/refiner.py
autonomous: true

must_haves:
  truths:
    - "Patch prompt includes talib avoidance instructions for ModuleNotFoundError/ImportError"
    - "Patch prompt includes 'do not modify tests' instruction"
    - "Refiner implements exponential backoff between retry attempts"
    - "Refiner tracks patch history and includes it in retry prompts"
    - "Unfixable errors (security violations, LLM API errors) cause immediate failure without retry"
  artifacts:
    - path: "fin_evo_agent/src/evolution/refiner.py"
      provides: "Enhanced generate_patch() with module guidance and history"
      contains: "FORBIDDEN: talib"
    - path: "fin_evo_agent/src/evolution/refiner.py"
      provides: "Exponential backoff in refine() loop"
      contains: "time.sleep"
  key_links:
    - from: "Refiner.generate_patch()"
      to: "LLMAdapter.generate_tool_code()"
      via: "patch_prompt"
      pattern: "module replacement guide"
    - from: "Refiner.refine()"
      to: "patch_history"
      via: "previous_patches"
      pattern: "history tracking"
---

<objective>
Enhance the patch generation and refinement loop by: (1) adding module replacement guide to patch prompt for import errors, (2) adding "do not modify tests" instruction, (3) implementing exponential backoff between retries, (4) tracking patch history to avoid repeating failed approaches, and (5) detecting unfixable errors for fail-fast.

Purpose: Even with correct error classification, the patch prompt needs explicit guidance to avoid forbidden modules (talib) and preserve test assertions. The retry loop needs backoff to avoid rate limits and history tracking to prevent spinning on the same fix.

Output: Enhanced refiner.py with improved generate_patch() and refine() methods.
</objective>

<execution_context>
@/Users/liuzhenqian/.claude/get-shit-done/workflows/execute-plan.md
@/Users/liuzhenqian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-refiner-pipeline-repair/03-RESEARCH.md
@.planning/phases/03-refiner-pipeline-repair/03-CONTEXT.md
@.planning/phases/03-refiner-pipeline-repair/03-01-PLAN.md
@fin_evo_agent/src/evolution/refiner.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add module replacement guide constant</name>
  <files>fin_evo_agent/src/evolution/refiner.py</files>
  <action>
Add a MODULE_REPLACEMENT_GUIDE constant near the top of refiner.py (after ERROR_PATTERNS, around line 60).

Insert this constant:

```python
# Module replacement guide for common talib replacements
MODULE_REPLACEMENT_GUIDE = """
## Module Replacement Guide (USE THESE)
FORBIDDEN: talib, yfinance, akshare, requests, os, sys, subprocess
USE INSTEAD: pandas, numpy for all calculations

### RSI (replace talib.RSI)
```python
delta = prices.diff()
gain = delta.clip(lower=0).rolling(period).mean()
loss = (-delta.clip(upper=0)).rolling(period).mean()
rs = gain / loss.replace(0, np.inf)
rsi = 100 - (100 / (1 + rs))
```

### MACD (replace talib.MACD)
```python
ema_fast = prices.ewm(span=fast, adjust=False).mean()
ema_slow = prices.ewm(span=slow, adjust=False).mean()
macd_line = ema_fast - ema_slow
signal = macd_line.ewm(span=signal_period, adjust=False).mean()
```

### Bollinger Bands (replace talib.BBANDS)
```python
middle = prices.rolling(period).mean()
std = prices.rolling(period).std()
upper = middle + (num_std * std)
lower = middle - (num_std * std)
```
"""
```

This constant will be used in generate_patch() for import-related errors.
  </action>
  <verify>
```bash
cd "/Users/liuzhenqian/Desktop/personal project/2026-1-week3/Insitu finance agent/fin_evo_agent"

python3 -c "
from src.evolution.refiner import MODULE_REPLACEMENT_GUIDE
assert 'FORBIDDEN: talib' in MODULE_REPLACEMENT_GUIDE, 'talib not in FORBIDDEN list'
assert 'RSI' in MODULE_REPLACEMENT_GUIDE, 'RSI example missing'
assert 'pandas' in MODULE_REPLACEMENT_GUIDE.lower(), 'pandas not mentioned'
print('PASS: MODULE_REPLACEMENT_GUIDE constant defined correctly')
"
```
Exit code 0 confirms success.
  </verify>
  <done>
MODULE_REPLACEMENT_GUIDE constant added with talib avoidance instructions and pandas/numpy replacement examples.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add UNFIXABLE_ERRORS constant</name>
  <files>fin_evo_agent/src/evolution/refiner.py</files>
  <action>
Add an UNFIXABLE_ERRORS set near the top of refiner.py (after MODULE_REPLACEMENT_GUIDE).

Insert this constant:

```python
# Errors that should not be retried (fail fast)
UNFIXABLE_ERRORS = {
    "SecurityException",      # AST blocked code
    "Unallowed import",       # Security violation
    "Unallowed call",         # Security violation
    "Unallowed attribute",    # Security violation
    "TimeoutError",           # External timeout
    "ConnectionError",        # Network failures
    "LLM API Error",          # LLM service failures
}
```

This set will be checked in refine() for immediate failure without retry.
  </action>
  <verify>
```bash
cd "/Users/liuzhenqian/Desktop/personal project/2026-1-week3/Insitu finance agent/fin_evo_agent"

python3 -c "
from src.evolution.refiner import UNFIXABLE_ERRORS
assert 'SecurityException' in UNFIXABLE_ERRORS or 'Unallowed import' in UNFIXABLE_ERRORS, 'Security errors missing'
assert isinstance(UNFIXABLE_ERRORS, (set, frozenset)), 'UNFIXABLE_ERRORS should be a set'
print(f'PASS: UNFIXABLE_ERRORS defined with {len(UNFIXABLE_ERRORS)} patterns')
"
```
Exit code 0 confirms success.
  </verify>
  <done>
UNFIXABLE_ERRORS set added with security violations, timeouts, and API errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add time import</name>
  <files>fin_evo_agent/src/evolution/refiner.py</files>
  <action>
Add `import time` to the imports section at the top of refiner.py (around line 11).

The imports section should look like:

```python
import re
import time
import uuid
from typing import Tuple, Optional, List
from datetime import datetime
```

This is needed for exponential backoff in the refine() loop.
  </action>
  <verify>
```bash
cd "/Users/liuzhenqian/Desktop/personal project/2026-1-week3/Insitu finance agent/fin_evo_agent"

python3 -c "
import ast
with open('src/evolution/refiner.py', 'r') as f:
    source = f.read()
tree = ast.parse(source)
imports = [node.names[0].name for node in ast.walk(tree) if isinstance(node, ast.Import)]
assert 'time' in imports, f'time not in imports: {imports}'
print('PASS: time module imported')
"
```
Exit code 0 confirms success.
  </verify>
  <done>
time module imported for exponential backoff functionality.
  </done>
</task>

<task type="auto">
  <name>Task 4: Enhance generate_patch() with module guide and history</name>
  <files>fin_evo_agent/src/evolution/refiner.py</files>
  <action>
Replace the generate_patch() method (lines 138-178) with an enhanced version that:
1. Accepts attempt number and previous patches
2. Includes module replacement guide for import errors
3. Includes history of failed patches on retries
4. Adds "do not modify tests" instruction

Replace the entire generate_patch() method with:

```python
def generate_patch(
    self,
    error_report: ErrorReport,
    original_code: str,
    task: str,
    attempt: int = 1,
    previous_patches: Optional[List[dict]] = None
) -> Optional[str]:
    """
    Generate patched code based on error analysis.

    Args:
        error_report: Error analysis from analyze_error()
        original_code: Original code that failed
        task: Original task description
        attempt: Current attempt number (1-3)
        previous_patches: List of previous patch attempts with failure reasons

    Returns:
        Patched code or None if generation failed
    """
    # Build history section for retries
    history_section = ""
    if previous_patches and attempt > 1:
        history_section = "\n## Previous Attempts (DO NOT REPEAT THESE APPROACHES)\n"
        for i, patch in enumerate(previous_patches, 1):
            history_section += f"\n### Attempt {i} - FAILED\n"
            history_section += f"What was tried: {patch.get('approach', 'Unknown')}\n"
            history_section += f"Why it failed: {patch.get('failure_reason', 'Unknown')}\n"

    # Module guidance for import errors
    module_guidance = ""
    if error_report.error_type in ("ModuleNotFoundError", "ImportError"):
        module_guidance = MODULE_REPLACEMENT_GUIDE

    patch_prompt = f"""修复以下Python代码中的错误。

## 原始任务
{task}

## 原始代码
```python
{original_code}
```

## 错误分析
错误类型: {error_report.error_type}
根本原因: {error_report.root_cause}
{module_guidance}
{history_section}

## 修复要求
1. 首先简要说明你将要修改什么以及为什么
2. 修复错误，保持原有功能
3. 只使用 pandas 和 numpy 进行计算 (不要使用 talib 或其他外部库)
4. 保留原有的类型注解和文档字符串
5. 保留 if __name__ == '__main__' 中的测试用例
6. 重要：不要修改测试断言 — 测试定义了期望行为，修复应使代码通过原始测试

只输出修复后的完整代码，用 ```python ``` 包裹。"""

    result = self.llm.generate_tool_code(patch_prompt)
    return result.get("code_payload")
```

Note: The method signature changes to accept `attempt` and `previous_patches` parameters.
  </action>
  <verify>
```bash
cd "/Users/liuzhenqian/Desktop/personal project/2026-1-week3/Insitu finance agent/fin_evo_agent"

python3 -c "
import inspect
from src.evolution.refiner import Refiner
r = Refiner()
sig = inspect.signature(r.generate_patch)
params = list(sig.parameters.keys())
assert 'attempt' in params, f'attempt param missing: {params}'
assert 'previous_patches' in params, f'previous_patches param missing: {params}'
print(f'PASS: generate_patch has required parameters: {params}')
"

# Verify prompt contains talib avoidance
python3 -c "
with open('src/evolution/refiner.py', 'r') as f:
    content = f.read()
assert 'MODULE_REPLACEMENT_GUIDE' in content, 'MODULE_REPLACEMENT_GUIDE not used in generate_patch'
assert '不要修改测试' in content or 'do not modify' in content.lower(), 'Test preservation instruction missing'
print('PASS: generate_patch includes module guide and test preservation')
"
```
Exit code 0 confirms success.
  </verify>
  <done>
generate_patch() enhanced with attempt/previous_patches parameters, module replacement guide for import errors, and "do not modify tests" instruction.
  </done>
</task>

<task type="auto">
  <name>Task 5: Enhance refine() with backoff, history, and fail-fast</name>
  <files>fin_evo_agent/src/evolution/refiner.py</files>
  <action>
Replace the refine() method (lines 180-268) with an enhanced version that:
1. Checks for unfixable errors first (fail-fast)
2. Implements exponential backoff (1s, 2s, 4s)
3. Tracks patch history with approach and failure reason
4. Passes history to generate_patch()

Replace the entire refine() method with:

```python
def refine(
    self,
    code: str,
    task: str,
    trace: ExecutionTrace,
    base_tool: Optional[ToolArtifact] = None,
    max_attempts: int = 3
) -> Tuple[Optional[ToolArtifact], List[ErrorReport]]:
    """
    Full refinement loop with retry, backoff, and history tracking.

    Args:
        code: Failed code to refine
        task: Original task description
        trace: Failed execution trace
        base_tool: Optional base tool (for versioning)
        max_attempts: Maximum refinement attempts

    Returns:
        (refined_tool, error_reports) - tool is None if all attempts failed
    """
    print(f"[Refiner] Starting refinement (max {max_attempts} attempts)")

    error_reports = []
    patch_history = []
    current_code = code
    current_trace = trace

    for attempt in range(max_attempts):
        # Check for unfixable errors first (fail-fast)
        stderr = current_trace.std_err or ""
        for unfixable in UNFIXABLE_ERRORS:
            if unfixable in stderr:
                print(f"[Refiner] Unfixable error detected: {unfixable} - aborting")
                return None, error_reports

        # Exponential backoff: 1s, 2s, 4s (skip on first attempt)
        if attempt > 0:
            delay = 2 ** (attempt - 1)  # 1, 2, 4 seconds
            print(f"[Refiner] Waiting {delay}s before attempt {attempt + 1}...")
            time.sleep(delay)

        print(f"\n[Refiner] Attempt {attempt + 1}/{max_attempts}")

        # 1. Analyze error
        print("[Refiner] Analyzing error...")
        error_report = self.analyze_error(current_trace, current_code)
        error_reports.append(error_report)
        print(f"  > Error type: {error_report.error_type}")
        print(f"  > Root cause: {error_report.root_cause[:100]}...")

        # 2. Generate patch with history
        print("[Refiner] Generating patch...")
        patched_code = self.generate_patch(
            error_report,
            current_code,
            task,
            attempt=attempt + 1,
            previous_patches=patch_history if patch_history else None
        )

        if not patched_code:
            print("  > Patch generation failed")
            patch_history.append({
                "approach": "LLM failed to generate code",
                "failure_reason": "No code payload returned"
            })
            continue

        # 3. Verify patch
        print("[Refiner] Verifying patch...")
        verify_trace = self.executor.execute(
            patched_code, "verify_only", {}, f"refine_{attempt}"
        )

        if verify_trace.exit_code == 0:
            print("[Refiner] Patch verified successfully!")

            # 4. Register patched tool
            func_name = extract_function_name(patched_code)
            if not func_name:
                print("  > Could not extract function name")
                patch_history.append({
                    "approach": "Patch generated but function name extraction failed",
                    "failure_reason": "No function definition found in patched code"
                })
                continue

            tool = self.registry.register(
                name=func_name,
                code=patched_code,
                args_schema=extract_args_schema(patched_code)
            )

            # 5. Create ToolPatch record
            if base_tool:
                patch_record = ToolPatch(
                    error_report_id=error_report.id,
                    base_tool_id=base_tool.id,
                    patch_diff=f"Refined from v{base_tool.semantic_version}",
                    rationale=error_report.root_cause,
                    resulting_tool_id=tool.id
                )
                with Session(self.engine) as session:
                    session.add(patch_record)
                    session.commit()

            print(f"[Refiner] Tool refined: {tool.name} v{tool.semantic_version}")
            return tool, error_reports

        else:
            failure_snippet = verify_trace.std_err[:200] if verify_trace.std_err else "Unknown error"
            print(f"  > Patch verification failed: {failure_snippet[:100]}...")

            # Track this failed attempt
            patch_history.append({
                "approach": f"Fixed {error_report.error_type}: {error_report.root_cause[:100]}",
                "failure_reason": failure_snippet
            })

            current_code = patched_code
            current_trace = verify_trace

    print(f"[Refiner] Failed after {max_attempts} attempts")
    return None, error_reports
```
  </action>
  <verify>
```bash
cd "/Users/liuzhenqian/Desktop/personal project/2026-1-week3/Insitu finance agent/fin_evo_agent"

# Verify refine() has exponential backoff
python3 -c "
with open('src/evolution/refiner.py', 'r') as f:
    content = f.read()
assert 'time.sleep' in content, 'time.sleep not found - exponential backoff missing'
assert 'UNFIXABLE_ERRORS' in content, 'UNFIXABLE_ERRORS check missing'
assert 'patch_history' in content, 'patch_history tracking missing'
print('PASS: refine() has backoff, fail-fast, and history tracking')
"

# Verify generate_patch is called with history
python3 -c "
with open('src/evolution/refiner.py', 'r') as f:
    content = f.read()
assert 'previous_patches=patch_history' in content or 'previous_patches=' in content, 'history not passed to generate_patch'
print('PASS: refine() passes history to generate_patch()')
"
```
Exit code 0 confirms success.
  </verify>
  <done>
refine() enhanced with exponential backoff (1s, 2s, 4s), unfixable error detection for fail-fast, and patch history tracking passed to generate_patch().
  </done>
</task>

</tasks>

<verification>
After all tasks complete, run this comprehensive verification:

```bash
cd "/Users/liuzhenqian/Desktop/personal project/2026-1-week3/Insitu finance agent/fin_evo_agent"

# 1. Verify MODULE_REPLACEMENT_GUIDE constant
python3 -c "
from src.evolution.refiner import MODULE_REPLACEMENT_GUIDE
assert 'talib' in MODULE_REPLACEMENT_GUIDE.lower(), 'FAIL: talib not mentioned'
print('[1/5] PASS: MODULE_REPLACEMENT_GUIDE defined')
"

# 2. Verify UNFIXABLE_ERRORS constant
python3 -c "
from src.evolution.refiner import UNFIXABLE_ERRORS
assert len(UNFIXABLE_ERRORS) > 0, 'FAIL: UNFIXABLE_ERRORS empty'
print('[2/5] PASS: UNFIXABLE_ERRORS defined')
"

# 3. Verify generate_patch signature
python3 -c "
import inspect
from src.evolution.refiner import Refiner
r = Refiner()
sig = inspect.signature(r.generate_patch)
params = list(sig.parameters.keys())
assert 'attempt' in params and 'previous_patches' in params, f'FAIL: missing params: {params}'
print('[3/5] PASS: generate_patch has new parameters')
"

# 4. Verify exponential backoff in refine()
python3 -c "
with open('src/evolution/refiner.py', 'r') as f:
    content = f.read()
assert 'time.sleep' in content, 'FAIL: time.sleep missing'
print('[4/5] PASS: Exponential backoff implemented')
"

# 5. Verify fail-fast for unfixable errors
python3 -c "
with open('src/evolution/refiner.py', 'r') as f:
    content = f.read()
assert 'UNFIXABLE_ERRORS' in content and 'unfixable' in content.lower(), 'FAIL: fail-fast logic missing'
print('[5/5] PASS: Fail-fast for unfixable errors')
"

echo ""
echo "=== All Plan 02 verifications passed ==="
```
</verification>

<success_criteria>
Phase 3 Plan 02 is complete when:

1. [x] MODULE_REPLACEMENT_GUIDE constant defined with talib avoidance and pandas/numpy examples
2. [x] UNFIXABLE_ERRORS set defined for fail-fast detection
3. [x] generate_patch() accepts attempt and previous_patches parameters
4. [x] generate_patch() includes module guide for import errors and "do not modify tests" instruction
5. [x] refine() implements exponential backoff (1s, 2s, 4s)
6. [x] refine() checks UNFIXABLE_ERRORS for fail-fast
7. [x] refine() tracks patch history and passes to generate_patch()

All verification commands exit with code 0.
</success_criteria>

<output>
After completion, create `.planning/phases/03-refiner-pipeline-repair/03-02-SUMMARY.md`
</output>
