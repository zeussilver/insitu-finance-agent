---
phase: 05-verification-gap-closure
plan: 12
type: execute
wave: 1
depends_on: []
files_modified:
  - fin_evo_agent/src/core/task_executor.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "yfinance fetch retries on failure (up to 3 attempts)"
    - "Exponential backoff between retries (1s, 2s, 4s)"
    - "Final failure includes all attempt errors in message"
  artifacts:
    - path: "fin_evo_agent/src/core/task_executor.py"
      provides: "Retry mechanism for yfinance fetch"
      contains: "retry"
  key_links:
    - from: "fetch_stock_data()"
      to: "get_stock_hist()"
      via: "Retry loop with backoff"
      pattern: "for attempt in range"
---

<objective>
Add yfinance Network Resilience with Retry Logic

Purpose: yfinance sometimes returns "No data" due to transient network issues, SSL errors, or rate limiting. Adding a retry mechanism with exponential backoff will improve reliability. The verification run showed ^GSPC, SPY, and ^DJI all failing with "No data returned" - retries may help.

Output: Modified fetch_stock_data() with 3-attempt retry and exponential backoff
</objective>

<execution_context>
@/Users/liuzhenqian/.claude/get-shit-done/workflows/execute-plan.md
@/Users/liuzhenqian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/05-verification-gap-closure/05-RE-VERIFICATION.md
@fin_evo_agent/src/core/task_executor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add retry logic to fetch_stock_data()</name>
  <files>fin_evo_agent/src/core/task_executor.py</files>
  <action>
  Add time import at the top of the file (around line 1-10):
  ```python
  import time
  ```

  Modify the fetch_stock_data() method (around line 168-207):

  CURRENT CODE:
  ```python
  def fetch_stock_data(
      self,
      symbol: str,
      start: str,
      end: str
  ) -> Dict[str, Any]:
      """
      Fetch OHLCV data using the data_proxy (cached).
      ...
      """
      try:
          df = get_stock_hist(symbol, start, end)

          if df is None or df.empty:
              raise ValueError(f"No data returned for {symbol}")
          ...
      except Exception as e:
          # Return error indicator - don't silently fail
          raise RuntimeError(f"Failed to fetch data for {symbol}: {e}")
  ```

  CHANGE TO:
  ```python
  # Retry configuration for yfinance network resilience
  MAX_FETCH_RETRIES = 3
  INITIAL_BACKOFF_SECONDS = 1.0

  def fetch_stock_data(
      self,
      symbol: str,
      start: str,
      end: str
  ) -> Dict[str, Any]:
      """
      Fetch OHLCV data using the data_proxy (cached).

      Includes retry logic with exponential backoff for network resilience.
      - Up to 3 attempts
      - Backoff: 1s, 2s, 4s between attempts
      - Final failure includes all attempt errors

      Returns standardized dict format:
      {
          'symbol': str,
          'dates': List[str],
          'open': List[float],
          'high': List[float],
          'low': List[float],
          'close': List[float],
          'volume': List[float]
      }
      """
      errors = []

      for attempt in range(self.MAX_FETCH_RETRIES):
          try:
              df = get_stock_hist(symbol, start, end)

              if df is None or df.empty:
                  raise ValueError(f"No data returned for {symbol}")

              # Convert DataFrame to dict with standardized format
              # Handle both string and numeric columns (from parquet cache)
              return {
                  'symbol': symbol,
                  'dates': df['Date'].astype(str).tolist() if 'Date' in df.columns else [],
                  'open': [float(x) for x in df['Open'].tolist()] if 'Open' in df.columns else [],
                  'high': [float(x) for x in df['High'].tolist()] if 'High' in df.columns else [],
                  'low': [float(x) for x in df['Low'].tolist()] if 'Low' in df.columns else [],
                  'close': [float(x) for x in df['Close'].tolist()] if 'Close' in df.columns else [],
                  'volume': [float(x) for x in df['Volume'].tolist()] if 'Volume' in df.columns else [],
              }

          except Exception as e:
              errors.append(f"Attempt {attempt + 1}: {e}")

              # Don't sleep after last attempt
              if attempt < self.MAX_FETCH_RETRIES - 1:
                  backoff = self.INITIAL_BACKOFF_SECONDS * (2 ** attempt)
                  time.sleep(backoff)

      # All retries failed
      error_summary = "; ".join(errors)
      raise RuntimeError(f"Failed to fetch data for {symbol} after {self.MAX_FETCH_RETRIES} attempts: {error_summary}")
  ```

  Add the class constants near the top of the TaskExecutor class (around line 62-64, after OHLCV_COLUMNS):
  ```python
  # Retry configuration for yfinance network resilience
  MAX_FETCH_RETRIES = 3
  INITIAL_BACKOFF_SECONDS = 1.0
  ```
  </action>
  <verify>
  Run the self-test:
  ```bash
  cd /Users/liuzhenqian/Desktop/personal\ project/2026-1-week3/Insitu\ finance\ agent/fin_evo_agent && python -m src.core.task_executor
  ```
  Expected: All tests pass (network test may show SKIP if network unavailable, which is OK)

  Also verify the constants exist:
  ```bash
  cd /Users/liuzhenqian/Desktop/personal\ project/2026-1-week3/Insitu\ finance\ agent/fin_evo_agent && grep -n "MAX_FETCH_RETRIES\|INITIAL_BACKOFF_SECONDS" src/core/task_executor.py
  ```
  Expected: Shows both constants defined
  </verify>
  <done>
  - fetch_stock_data() has 3-attempt retry loop
  - Exponential backoff (1s, 2s, 4s) between retries
  - Final error includes all attempt error messages
  - Self-tests pass
  </done>
</task>

</tasks>

<verification>
1. Self-test passes: `python -m src.core.task_executor` completes without error
2. grep confirms MAX_FETCH_RETRIES and INITIAL_BACKOFF_SECONDS constants exist
3. Code review confirms retry loop structure with exponential backoff
</verification>

<success_criteria>
- fetch_stock_data() retries up to 3 times on failure
- Backoff doubles each attempt (1s -> 2s -> 4s)
- Error message on final failure includes all attempt errors
- Existing functionality preserved (returns same dict format)
</success_criteria>

<output>
After completion, create `.planning/phases/05-verification-gap-closure/05-12-SUMMARY.md`
</output>
