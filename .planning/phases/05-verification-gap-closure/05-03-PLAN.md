---
phase: 05-verification-gap-closure
plan: 03
type: execute
wave: 2
depends_on:
  - "05-02"
files_modified:
  - fin_evo_agent/src/core/registry.py
  - fin_evo_agent/src/evolution/synthesizer.py
autonomous: true

must_haves:
  truths:
    - "Registry can find tools by schema fields (category, indicator)"
    - "Synthesizer extracts and stores schema metadata when registering tools"
    - "Schema-based matching is more precise than keyword matching"
  artifacts:
    - path: "fin_evo_agent/src/core/registry.py"
      provides: "Schema-based tool retrieval"
      contains: "find_by_schema"
    - path: "fin_evo_agent/src/evolution/synthesizer.py"
      provides: "Schema extraction during synthesis"
      contains: "category="
  key_links:
    - from: "registry.find_by_schema()"
      to: "ToolArtifact schema fields"
      via: "SQLModel query with filters"
      pattern: "ToolArtifact\\.category"
---

<objective>
Implement structured schema matching in the registry and synthesizer.

Purpose: Replace keyword-based `_infer_tool_name()` matching with precise schema-based matching. Tools are matched by category (fetch/calculation/composite), indicator type (rsi/macd/etc.), and data requirements.

Output: New `find_by_schema()` method in ToolRegistry, schema extraction in Synthesizer during tool registration.
</objective>

<execution_context>
@/Users/liuzhenqian/.claude/get-shit-done/workflows/execute-plan.md
@/Users/liuzhenqian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-verification-gap-closure/05-CONTEXT.md
@.planning/phases/05-verification-gap-closure/05-RESEARCH.md
@fin_evo_agent/src/core/registry.py
@fin_evo_agent/src/evolution/synthesizer.py
@fin_evo_agent/src/core/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add schema-based tool retrieval to Registry</name>
  <files>fin_evo_agent/src/core/registry.py</files>
  <action>
Add a new `find_by_schema()` method to ToolRegistry class:

```python
def find_by_schema(
    self,
    category: Optional[str] = None,
    indicator: Optional[str] = None,
    data_type: Optional[str] = None,
    status: ToolStatus = ToolStatus.PROVISIONAL
) -> Optional[ToolArtifact]:
    """
    Find tool by structured schema fields.

    This replaces keyword-based matching with precise field matching.
    Returns the latest version if multiple matches exist.

    Args:
        category: Task category ('fetch', 'calculation', 'composite')
        indicator: Technical indicator ('rsi', 'macd', 'bollinger', etc.)
        data_type: Data type ('price', 'financial', 'volume')
        status: Tool status filter (default: PROVISIONAL)

    Returns:
        ToolArtifact if found, None otherwise
    """
    with Session(self.engine) as session:
        query = select(ToolArtifact).where(ToolArtifact.status == status)

        if category:
            query = query.where(ToolArtifact.category == category)
        if indicator:
            query = query.where(ToolArtifact.indicator == indicator)
        if data_type:
            query = query.where(ToolArtifact.data_type == data_type)

        results = list(session.exec(query).all())

        if not results:
            return None

        # Return latest version if multiple matches
        return max(results, key=lambda t: t.semantic_version)
```

Also add a helper method to update schema fields:

```python
def update_schema(
    self,
    tool_id: int,
    category: str = None,
    indicator: str = None,
    data_type: str = None,
    input_requirements: List[str] = None
) -> Optional[ToolArtifact]:
    """Update schema fields for an existing tool."""
    with Session(self.engine) as session:
        tool = session.get(ToolArtifact, tool_id)
        if tool:
            if category is not None:
                tool.category = category
            if indicator is not None:
                tool.indicator = indicator
            if data_type is not None:
                tool.data_type = data_type
            if input_requirements is not None:
                tool.input_requirements = input_requirements
            session.add(tool)
            session.commit()
            session.refresh(tool)
        return tool
```

Ensure `Optional` is imported from typing (add if not present).
  </action>
  <verify>
Run:
```bash
cd fin_evo_agent && python -c "
from src.core.registry import ToolRegistry
from src.core.models import init_db, ToolStatus

# Initialize
init_db()
registry = ToolRegistry()

# Test find_by_schema exists and works
result = registry.find_by_schema(category='calculation', indicator='rsi')
print(f'find_by_schema(calculation, rsi) returned: {type(result).__name__}')

# Test with no matches
result2 = registry.find_by_schema(category='nonexistent')
print(f'find_by_schema(nonexistent) returned: {result2}')

# Test update_schema exists
import inspect
assert hasattr(registry, 'update_schema'), 'Missing update_schema method'
sig = inspect.signature(registry.update_schema)
print(f'update_schema params: {list(sig.parameters.keys())}')

print('PASS: Schema methods added to registry')
"
```
  </verify>
  <done>
- `find_by_schema()` method exists with category, indicator, data_type params
- `update_schema()` method exists to modify schema fields
- Methods work with empty database (return None for no matches)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add schema extraction to Synthesizer</name>
  <files>fin_evo_agent/src/evolution/synthesizer.py</files>
  <action>
Update the Synthesizer to extract and store schema metadata when registering tools.

1. **Add helper function** at module level (after existing helper functions):

```python
# Indicator keywords for schema extraction
INDICATOR_KEYWORDS = {
    'rsi': ['rsi', '相对强弱', 'relative strength'],
    'macd': ['macd', '指数平滑异同'],
    'bollinger': ['bollinger', '布林', 'boll'],
    'kdj': ['kdj', '随机指标'],
    'ma': ['moving average', 'ma', '移动平均'],
    'volatility': ['volatility', '波动率'],
    'drawdown': ['drawdown', '回撤', 'max_drawdown'],
    'correlation': ['correlation', '相关系数', '相关性'],
    'volume_price': ['volume price', '量价', 'divergence'],
    'portfolio': ['portfolio', '组合', 'weight'],
}

def extract_indicator(task: str, code: str) -> Optional[str]:
    """Extract indicator type from task description or code."""
    text = (task + ' ' + code).lower()
    for indicator, keywords in INDICATOR_KEYWORDS.items():
        if any(kw in text for kw in keywords):
            return indicator
    return None

def extract_data_type(task: str, args_schema: dict) -> str:
    """Infer data type from task and function arguments."""
    task_lower = task.lower()
    if any(kw in task_lower for kw in ['financial', '财务', 'net income', '净利润', 'revenue', 'roe']):
        return 'financial'
    if any(kw in task_lower for kw in ['volume', '成交量', '量']):
        return 'volume'
    if 'ohlcv' in str(args_schema).lower() or all(k in str(args_schema).lower() for k in ['open', 'high', 'low', 'close']):
        return 'ohlcv'
    return 'price'  # default
```

2. **Update the `synthesize()` method** to pass schema fields during registration:

Find this line in `synthesize()`:
```python
tool = self.registry.register(
    name=func_name,
    code=code,
    args_schema=args_schema,
    permissions=[Permission.CALC_ONLY.value]
)
```

Replace with:
```python
# Extract schema metadata
indicator = extract_indicator(task, code)
data_type = extract_data_type(task, args_schema)

# Infer category from task keywords
task_lower = task.lower()
if any(kw in task_lower for kw in ['获取', 'fetch', 'get', '查询', '历史']):
    category = 'fetch'
elif any(kw in task_lower for kw in ['计算', 'calc', 'calculate', '指标']):
    category = 'calculation'
else:
    category = 'composite'

# Get input requirements from args_schema
input_requirements = list(args_schema.keys()) if args_schema else []

tool = self.registry.register(
    name=func_name,
    code=code,
    args_schema=args_schema,
    permissions=[Permission.CALC_ONLY.value]
)

# Update schema fields after registration
if tool:
    self.registry.update_schema(
        tool.id,
        category=category,
        indicator=indicator,
        data_type=data_type,
        input_requirements=input_requirements
    )
```

Also ensure the `Optional` import is present at the top of the file.
  </action>
  <verify>
Run:
```bash
cd fin_evo_agent && python -c "
from src.evolution.synthesizer import extract_indicator, extract_data_type, INDICATOR_KEYWORDS

# Test indicator extraction
assert extract_indicator('计算 RSI 指标', 'def calc_rsi') == 'rsi'
assert extract_indicator('calculate MACD', 'def calc_macd') == 'macd'
assert extract_indicator('compute bollinger bands', 'def bollinger') == 'bollinger'
print('Indicator extraction: PASS')

# Test data type extraction
assert extract_data_type('获取财务数据', {}) == 'financial'
assert extract_data_type('计算RSI', {'prices': 'list'}) == 'price'
print('Data type extraction: PASS')

# Verify synthesizer has the logic
import inspect
from src.evolution.synthesizer import Synthesizer
source = inspect.getsource(Synthesizer.synthesize)
assert 'extract_indicator' in source, 'Missing extract_indicator call in synthesize()'
assert 'category' in source, 'Missing category extraction in synthesize()'
print('Synthesizer integration: PASS')

print('All schema extraction tests passed!')
"
```
  </verify>
  <done>
- INDICATOR_KEYWORDS dict defined with 10 indicator types
- `extract_indicator()` function works for common indicators
- `extract_data_type()` function infers data type from task
- `synthesize()` method extracts and stores schema metadata
- `registry.update_schema()` called after registration
  </done>
</task>

</tasks>

<verification>
1. `find_by_schema()` returns tools matching category and indicator
2. `update_schema()` can modify schema fields on existing tools
3. Schema extraction correctly identifies indicator types
4. Newly synthesized tools have schema fields populated
5. No regression in existing synthesis flow
</verification>

<success_criteria>
- Registry has `find_by_schema(category, indicator, data_type)` method
- Registry has `update_schema(tool_id, ...)` method
- Synthesizer extracts indicator type from task description
- Synthesizer infers category from keywords (fetch/calculation/composite)
- Synthesizer populates input_requirements from args_schema
- Newly registered tools have non-null schema fields
</success_criteria>

<output>
After completion, create `.planning/phases/05-verification-gap-closure/05-03-SUMMARY.md`
</output>
