---
phase: 05-verification-gap-closure
plan: 04
type: execute
wave: 2
depends_on:
  - "05-02"
files_modified:
  - fin_evo_agent/src/core/task_executor.py
autonomous: true

must_haves:
  truths:
    - "TaskExecutor can fetch OHLCV data using bootstrap tools"
    - "TaskExecutor can chain fetch + calc operations"
    - "Pure calc tools receive data as arguments (not fetching internally)"
    - "Standardized OHLCV format matches yfinance DataFrame columns"
  artifacts:
    - path: "fin_evo_agent/src/core/task_executor.py"
      provides: "Task orchestration with bootstrap tool chaining"
      contains: "class TaskExecutor"
  key_links:
    - from: "TaskExecutor.execute_task()"
      to: "bootstrap get_stock_hist tool"
      via: "fetch_stock_data() method"
      pattern: "get_stock_hist"
---

<objective>
Create a TaskExecutor module that orchestrates task execution by chaining bootstrap fetch tools with generated calc tools.

Purpose: The current system expects generated tools to be pure functions (data-as-arguments), but fetch tasks need to actually retrieve data. TaskExecutor bridges this gap: the system fetches data using bootstrap tools, then passes it to pure calc tools.

Output: New `src/core/task_executor.py` module with TaskExecutor class that handles fetch/calc/composite task patterns.
</objective>

<execution_context>
@/Users/liuzhenqian/.claude/get-shit-done/workflows/execute-plan.md
@/Users/liuzhenqian/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-verification-gap-closure/05-CONTEXT.md
@.planning/phases/05-verification-gap-closure/05-RESEARCH.md
@fin_evo_agent/src/finance/bootstrap.py
@fin_evo_agent/src/core/executor.py
@fin_evo_agent/src/core/registry.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TaskExecutor module</name>
  <files>fin_evo_agent/src/core/task_executor.py</files>
  <action>
Create a new file `fin_evo_agent/src/core/task_executor.py` with the following content:

```python
"""Task Executor: Orchestrates task execution with bootstrap tool chaining.

This module bridges the gap between:
- Pure calc tools (expect data as arguments)
- Fetch tasks (need to retrieve data from yfinance)

Pattern: System fetches data via bootstrap tools, then passes to calc tools.
"""

import re
from typing import Dict, Any, Optional, Tuple
from pathlib import Path

import sys
sys.path.insert(0, str(__file__).rsplit("/", 3)[0])

from src.core.registry import ToolRegistry
from src.core.executor import ToolExecutor
from src.core.models import ToolArtifact, ExecutionTrace
from src.finance.data_proxy import get_stock_hist


class TaskExecutor:
    """Orchestrates task execution by chaining bootstrap fetch with calc tools."""

    # Standard OHLCV columns from yfinance
    OHLCV_COLUMNS = ['Date', 'Open', 'High', 'Low', 'Close', 'Volume']

    # Mapping of task patterns to bootstrap tools
    FETCH_TOOL_MAPPING = {
        'stock_hist': 'get_stock_hist',
        'financial': 'get_financial_info',
        'quote': 'get_realtime_quote',
        'index': 'get_index_daily',
        'etf': 'get_etf_hist',
    }

    def __init__(
        self,
        registry: ToolRegistry = None,
        executor: ToolExecutor = None
    ):
        self.registry = registry or ToolRegistry()
        self.executor = executor or ToolExecutor()
        self._bootstrap_cache: Dict[str, ToolArtifact] = {}

    def get_bootstrap_tool(self, tool_name: str) -> Optional[ToolArtifact]:
        """Get a bootstrap tool by name (cached)."""
        if tool_name not in self._bootstrap_cache:
            tool = self.registry.get_by_name(tool_name)
            if tool and 'bootstrap' in tool.file_path:
                self._bootstrap_cache[tool_name] = tool
        return self._bootstrap_cache.get(tool_name)

    def extract_symbol(self, query: str) -> str:
        """Extract stock symbol from query string."""
        query_upper = query.upper()

        # Common US tickers
        us_tickers = ['AAPL', 'MSFT', 'GOOGL', 'GOOG', 'AMZN', 'TSLA', 'META', 'NVDA', 'AMD', 'INTC']
        for ticker in us_tickers:
            if ticker in query_upper:
                return ticker

        # Pattern match for ticker-like strings
        match = re.search(r'\b([A-Z]{2,5})\b', query_upper)
        if match:
            return match.group(1)

        return 'AAPL'  # Default

    def extract_date_range(self, query: str) -> Tuple[str, str]:
        """Extract date range from query, or return default."""
        # Try to find date patterns
        date_pattern = r'(\d{4}-\d{2}-\d{2})'
        dates = re.findall(date_pattern, query)

        if len(dates) >= 2:
            return dates[0], dates[1]
        elif len(dates) == 1:
            return dates[0], '2023-12-31'

        # Default date range
        return '2023-01-01', '2023-12-31'

    def fetch_stock_data(
        self,
        symbol: str,
        start: str,
        end: str
    ) -> Dict[str, Any]:
        """
        Fetch OHLCV data using the data_proxy (cached).

        Returns standardized dict format:
        {
            'symbol': str,
            'dates': List[str],
            'open': List[float],
            'high': List[float],
            'low': List[float],
            'close': List[float],
            'volume': List[float]
        }
        """
        try:
            df = get_stock_hist(symbol, start, end)

            if df is None or df.empty:
                raise ValueError(f"No data returned for {symbol}")

            # Convert DataFrame to dict with standardized format
            # Handle both string and numeric columns (from parquet cache)
            return {
                'symbol': symbol,
                'dates': df['Date'].astype(str).tolist() if 'Date' in df.columns else [],
                'open': [float(x) for x in df['Open'].tolist()] if 'Open' in df.columns else [],
                'high': [float(x) for x in df['High'].tolist()] if 'High' in df.columns else [],
                'low': [float(x) for x in df['Low'].tolist()] if 'Low' in df.columns else [],
                'close': [float(x) for x in df['Close'].tolist()] if 'Close' in df.columns else [],
                'volume': [float(x) for x in df['Volume'].tolist()] if 'Volume' in df.columns else [],
            }
        except Exception as e:
            # Return error indicator - don't silently fail
            raise RuntimeError(f"Failed to fetch data for {symbol}: {e}")

    def prepare_calc_args(
        self,
        data: Dict[str, Any],
        task: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Prepare arguments for a calc tool from fetched data and task params.

        Maps OHLCV data to common calc tool argument names.
        """
        args = {
            # Primary price data (most calc tools use 'prices')
            'prices': data.get('close', []),

            # Individual OHLCV columns for tools that need them
            'open': data.get('open', []),
            'high': data.get('high', []),
            'low': data.get('low', []),
            'close': data.get('close', []),
            'volume': data.get('volume', []),
            'dates': data.get('dates', []),

            # Symbol info
            'symbol': data.get('symbol', ''),
        }

        # Extract task-specific parameters
        args.update(self._extract_task_params(task))

        return args

    def _extract_task_params(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Extract calculation parameters from task query."""
        query = task.get('query', '')
        params = {}

        # RSI period
        if match := re.search(r'RSI[- ]?(\d+)', query, re.I):
            params['period'] = int(match.group(1))
        elif 'rsi' in query.lower():
            params['period'] = 14  # default RSI period

        # MACD parameters
        if match := re.search(r'MACD\s*\(?\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)', query, re.I):
            params['fast_period'] = int(match.group(1))
            params['slow_period'] = int(match.group(2))
            params['signal_period'] = int(match.group(3))
        elif 'macd' in query.lower():
            params['fast_period'] = 12
            params['slow_period'] = 26
            params['signal_period'] = 9

        # KDJ parameters
        if 'kdj' in query.lower():
            params['k_period'] = 9
            params['d_period'] = 3

        # Bollinger bands
        if match := re.search(r'(\d+)\s*day', query.lower()):
            params['window'] = int(match.group(1))
        elif 'bollinger' in query.lower() or '布林' in query:
            params['window'] = 20
            params['num_std'] = 2

        # Generic period/window
        if 'period' not in params and 'window' not in params:
            if match := re.search(r'(\d+)\s*(天|日|day|period)', query.lower()):
                params['period'] = int(match.group(1))

        return params

    def execute_task(
        self,
        task: Dict[str, Any],
        tool: ToolArtifact
    ) -> ExecutionTrace:
        """
        Execute a task using the appropriate pattern.

        For fetch/calculation/composite categories:
        1. Fetch data using bootstrap tools
        2. Prepare arguments
        3. Execute the tool with data
        """
        category = task.get('category', 'calculation')
        task_id = task.get('task_id', 'unknown')

        # Fetch data if needed
        if category in ('fetch', 'calculation', 'composite'):
            try:
                symbol = self.extract_symbol(task.get('query', ''))
                start, end = self.extract_date_range(task.get('query', ''))

                data = self.fetch_stock_data(symbol, start, end)
                args = self.prepare_calc_args(data, task)
            except Exception as e:
                # Return error trace for fetch failures
                return ExecutionTrace(
                    trace_id=f"fetch_error_{task_id}",
                    task_id=task_id,
                    input_args={'error': str(e)},
                    output_repr="",
                    exit_code=1,
                    std_out="",
                    std_err=f"Data fetch failed: {e}",
                    execution_time_ms=0
                )
        else:
            args = self._extract_task_params(task)

        # Execute the tool
        return self.executor.execute(
            tool.code_content,
            tool.name,
            args,
            task_id
        )


if __name__ == "__main__":
    # Test TaskExecutor
    from src.core.models import init_db

    print("Initializing...")
    init_db()

    task_executor = TaskExecutor()

    # Test symbol extraction
    assert task_executor.extract_symbol("计算AAPL的RSI") == "AAPL"
    assert task_executor.extract_symbol("计算MSFT的MACD") == "MSFT"
    print("Symbol extraction: PASS")

    # Test date extraction
    start, end = task_executor.extract_date_range("2023-01-01到2023-06-30")
    assert start == "2023-01-01", f"Got {start}"
    assert end == "2023-06-30", f"Got {end}"
    print("Date extraction: PASS")

    # Test data fetch (uses cache)
    try:
        data = task_executor.fetch_stock_data("AAPL", "2023-01-01", "2023-01-10")
        assert 'close' in data
        assert len(data['close']) > 0
        print(f"Data fetch: PASS ({len(data['close'])} rows)")
    except Exception as e:
        print(f"Data fetch: SKIP (network issue: {e})")

    # Test param extraction
    task = {'query': '计算RSI-14指标'}
    params = task_executor._extract_task_params(task)
    assert params.get('period') == 14, f"Got {params}"
    print("Param extraction: PASS")

    print("\nAll TaskExecutor tests passed!")
```
  </action>
  <verify>
Run:
```bash
cd fin_evo_agent && python -c "
from src.core.task_executor import TaskExecutor
import inspect

# Check class exists with expected methods
te = TaskExecutor()
assert hasattr(te, 'fetch_stock_data'), 'Missing fetch_stock_data'
assert hasattr(te, 'execute_task'), 'Missing execute_task'
assert hasattr(te, 'prepare_calc_args'), 'Missing prepare_calc_args'
assert hasattr(te, 'extract_symbol'), 'Missing extract_symbol'

# Check OHLCV_COLUMNS constant
assert 'Close' in TaskExecutor.OHLCV_COLUMNS

print('TaskExecutor class structure: PASS')
"

# Run the built-in tests
cd fin_evo_agent && python src/core/task_executor.py
```
  </verify>
  <done>
- TaskExecutor class created in src/core/task_executor.py
- fetch_stock_data() returns standardized OHLCV dict
- execute_task() chains fetch + execute for calc tasks
- prepare_calc_args() maps data to common argument names
- extract_symbol() and extract_date_range() parse task queries
- _extract_task_params() handles RSI, MACD, KDJ, Bollinger params
- Built-in tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Test TaskExecutor with a calc tool</name>
  <files>fin_evo_agent/src/core/task_executor.py</files>
  <action>
Create an integration test to verify TaskExecutor can:
1. Fetch data using bootstrap tool (via data_proxy cache)
2. Execute a calculation tool with the fetched data
3. Return proper results

Run this test to verify end-to-end flow:

```bash
cd fin_evo_agent && python -c "
from src.core.task_executor import TaskExecutor
from src.core.models import init_db
from src.core.registry import ToolRegistry

init_db()

# Create a simple test calc tool
registry = ToolRegistry()
test_code = '''
import pandas as pd

def test_calc_mean(prices: list) -> float:
    '''Calculate mean of prices.'''
    return float(pd.Series(prices).mean())

if __name__ == '__main__':
    assert test_calc_mean([1, 2, 3, 4, 5]) == 3.0
'''

# Register the test tool
tool = registry.register(name='test_calc_mean', code=test_code)
print(f'Registered test tool: {tool.name}')

# Execute with TaskExecutor
task_executor = TaskExecutor(registry=registry)
task = {
    'task_id': 'test_001',
    'category': 'calculation',
    'query': '计算AAPL平均价格',
}

trace = task_executor.execute_task(task, tool)
print(f'Execution result: exit_code={trace.exit_code}')
print(f'Output: {trace.std_out[:200] if trace.std_out else trace.std_err[:200]}')

if trace.exit_code == 0:
    print('Integration test: PASS')
else:
    print(f'Integration test: FAIL - {trace.std_err}')
"
```
  </action>
  <verify>
The integration test above should show:
- Test tool registered successfully
- Execution returns exit_code=0
- Output contains a numeric result (mean price)
  </verify>
  <done>
- TaskExecutor can fetch data for any symbol
- TaskExecutor can execute calc tools with fetched data
- Data flows correctly: bootstrap fetch -> standardized dict -> calc tool args
- Errors are properly captured in ExecutionTrace
  </done>
</task>

</tasks>

<verification>
1. TaskExecutor module exists at src/core/task_executor.py
2. fetch_stock_data() returns standardized OHLCV dict
3. execute_task() handles fetch/calculation/composite categories
4. Integration test passes (fetch + calc chain works)
5. Module is importable from both main.py and benchmarks/run_eval.py
</verification>

<success_criteria>
- TaskExecutor class with execute_task(), fetch_stock_data(), prepare_calc_args() methods
- OHLCV data format: {symbol, dates, open, high, low, close, volume}
- Calc tools receive data as arguments (not fetching internally)
- Integration test shows end-to-end flow working
- No regressions in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/05-verification-gap-closure/05-04-SUMMARY.md`
</output>
